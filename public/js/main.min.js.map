{"version":3,"file":"main.min.js","sources":["webpack:///webpack/bootstrap 343870a8fadcfc23b53b","webpack:///./src/js/main.js","webpack:///./src/js/caculate.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 343870a8fadcfc23b53b","let cacu = require('./caculate.js');\r\n\r\nvar create = cacu.create;\r\n\r\n// 处理运算\r\nfunction dealCacu(input, resultDiv) {\r\n\tvar\tres = cacu(input.val()), isSuccess;\r\n\tif(typeof res === 'number') {\r\n\t\tisSuccess = true;\r\n\t\tif(res !== res) res = '运算结果为: NaN, 无意义的运算';\r\n\t\telse if(/Infinity/.test(res.toString())) res = '无穷：'+res.toString().replace(/Infinity/, 'n');\r\n\t\telse res = `您的运算结果为：${res}`;\r\n\t} else {\r\n\t\tisSuccess = false;\r\n\t}\r\n\tshowRes(resultDiv, isSuccess, res);\r\n}\r\n\r\n// 处理新建常量\r\nfunction createConstant(input, resultDiv) {\r\n\tvar name = input.eq(0).val(),\r\n\t\tvalue = input.eq(1).val(),\r\n\t\tres = create.validVarible(name, value);\r\n\t\r\n\tif(typeof res !== 'string') {\r\n\t\tcreate.createVarible(name, value);\r\n\t\tshowRes(resultDiv, true, `创建成功！常量名:${name} 常量值:${value}`);\r\n\t} else {\r\n\t\tshowRes(resultDiv, false, res);\r\n\t}\r\n}\r\n\r\n// 处理新建方法\r\nfunction createMethod(input, resultDiv) {\r\n\tvar name = input.eq(0).val(),\r\n\t\tvalue = input.eq(1).val(),\r\n\t\tres = create.validMethod(name, value);\r\n\t\r\n\tif(typeof res !== 'string') {\r\n\t\tcreate.createMethod(name, value);\r\n\t\tshowRes(resultDiv, true, `创建成功！常量名:${name} 常量值:${value}`);\r\n\t} else {\r\n\t\tshowRes(resultDiv, false, res);\r\n\t}\r\n}\r\n\r\n// 显示结果\r\nfunction showRes(resultDiv, isSuccess, message) {\r\n\tif(isSuccess) resultDiv.removeClass('error').addClass('correct');\r\n\telse resultDiv.removeClass('correct').addClass('error');\r\n\tresultDiv.text(message).slideDown('slow');\r\n}\r\n\r\n// 获得结果， 封装的一个处理计算 和 创建常量及方法的函数\r\nfunction getRes(elem) {\r\n\tvar parent = elem.parent(), \r\n\t\tinput = elem.siblings('input'),\r\n\t\tresultDiv = elem.siblings('.result');\r\n\tif(parent.hasClass('content')) {\r\n\t// 处理运算\r\n\t\tdealCacu(input, resultDiv);\r\n\t} else if(parent.hasClass('constant')){\r\n\t// 处理新建常量\r\n\t\tcreateConstant(input, resultDiv);\r\n\t} else {\r\n\t// 处理新建方法\r\n\t\tcreateMethod(input, resultDiv);\r\n\t}\r\n}\r\n\r\n// 绑定按钮的点击事件\r\n$('button').click(function() {\r\n\tgetRes($(this));\r\n});\r\n\r\n// 绑定按键事件，按回车的时候相当于点击按钮， 按其他键的时候则隐藏结果\r\n$('input').keyup(function(e) {\r\n\tif(e.keyCode === 13) {\r\n\t\tgetRes($(this).parent().find('button'));\r\n\t} else {\r\n\t\t$('.result').slideUp('slow');\r\n\t}\r\n});\r\n\r\n$('input').click(function(){\r\n\t$('.result').slideUp('slow');\r\n})\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/main.js\n// module id = 0\n// module chunks = 0","function caculate (str) {\r\n\tvar result;\r\n\tfunction innerCaculate (str) {\r\n\t\tvar ori = str,\r\n\t\t\tindex = 0,\r\n\t\t\tres;\r\n\t\t// 第一步  替换掉所有的空白类字符并检验是否有非法字符存在\r\n\t\tstr = str.replace(/\\s/g, '');\r\n\t\tif(!str) throw new Error('并没有输入任何有意义的运算');\r\n\t\tif(/[^\\w+\\-*/()π^%,\\.]/.test(str)) throw new Error('包含非法字符~')\r\n\t\t// 第二步  将常量名转换为常量值   π比较特殊，不算在\\w里面, 正则中另做处理\r\n\t\tstr = str.replace(/(\\b[a-z_]\\w*\\b|\\Bπ\\B)(?!\\()/gi, v => {\r\n\t\t\tif(!replaceMethods[v]) {\r\n\t\t\t\tthrow new Error(`不存在的常量名: ${v}`);\r\n\t\t\t} else if(replaceMethods[v] && typeof replaceMethods[v] !== 'number') {\r\n\t\t\t\tthrow new Error(`不能把方法: ${v} 当常量用`);\r\n\t\t\t} else {\r\n\t\t\t\treturn replaceMethods[v];\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// 第三步  将幂运算符及前后数值进行计算，转化为结果数值\r\n\t\t// 把^幂运算装换为pow方法  ^前后只能有单数字或常量，不能嵌套圆括号或者方法\r\n\t\t// 如果你想嵌套，可以使用pow\r\n\t\t// eg: (5+2) ^ Math.abs(2.4)   错误，报错“错误的使用: ^幂运算符”，请改用pow\r\n\t\t//     pow((5+2), Math.abs(2.4)) 正确\r\n\t\tstr = str.replace(/\\b(\\d(?:\\.\\d*)?)\\^((\\d(?:\\.\\d*)?))\\b/, (v, a, b) => Math.pow(a, b));\r\n\r\n\t\t// 第四步 在第三步替换掉幂运算符后如果还存在^， 代表其使用错误，报错。\r\n\t\tif(/\\^/.test(str)) throw new Error('错误的使用: ^幂运算符');\r\n\r\n\t\t// 第五步 处理方法或者圆括号内的内容, 将其转换为确切的数值.\r\n\t\t// eg: pow(2,3) => 8,   (1+2+3) => 6s\r\n\t\twhile(/\\b([a-z_]\\w*)?\\([^(]*?\\)/i.test(str)) {\r\n\t\t\tstr = str.replace(/\\b([a-z_]\\w*)?\\(([^(]*?)\\)/i, (...arg) => {\r\n\t\t\t\tlet res, method = arg[1];\r\n\t\t\r\n\t\t\t\t// 如果没有匹配到方法名， 代表是纯运算式，直接eval求值。\r\n\t\t\t\tif(method === undefined) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tres = eval(arg[0])\r\n\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\tthrow new Error('不正确的算术格式~')\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet usage = replaceMethods[method];\r\n\t\t\t\t\tif(usage) {\r\n\t\t\t\t\t\t// 如果匹配到的方法名存在且是函数形式，则带参数求值\r\n\t\t\t\t\t\t// 不需要考虑参数数量限制， 这个判断逻辑放在replaceMethods的相应方法中\r\n\t\t\t\t\t\t// 而replaceMethods的方法通过bindArgNum再包装，可以判断\r\n\t\t\t\t\t\tif(usage instanceof Function) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tres = eval(`replaceMethods.${arg[1]}(${arg[2]})`);\r\n\t\t\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t\t\tif(e.message.indexOf('传入') > -1) throw e;\r\n\t\t\t\t\t\t\t\telse throw new Error('不正确的算术格式~');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if(typeof usage === 'number') {\r\n\t\t\t\t\t\t\tthrow new Error(`不能将常量 ${method} 当方法用`);\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 如果匹配到的方法名不存在，则报错\r\n\t\t\t\t\t\tthrow new Error(`不存在的方法名: ${method}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t});\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tres = eval(str);\r\n\t\t} catch(e) {\r\n\t\t\tthrow new Error('不正确的算术格式~');\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t// 捕获错误，并在catch中提示用户。\r\n\ttry {\r\n\r\n\t\tresult = innerCaculate(str);\r\n\r\n\t} catch(e) {\r\n\r\n\t\treturn e.message;\r\n\r\n\t}\r\n\t// 只精确到小数点后15位， 避免双浮点精度丢失\r\n\t// 15位防止Math.sin精度丢失 16位防止0.1+0.2这种情况\r\n\treturn +result.toFixed(15);\r\n};\r\n\r\n// 管理计算器的状态 \r\nlet status = {\r\n\tisAngle: true,\r\n\targModel: 0,\r\n\tallowVar: false\r\n};\r\n\r\n// 一个储存自己数学方法的仓库\r\nlet util = {\r\n\tavg: (...arr) => util.sum.apply(null, arr) / arr.length,\r\n\r\n\tcot: num => Math.cos(num) / Math.sin(num),\r\n\t\r\n\tlog: (num1, num2) => Math.log(num1) / Math.log(num2),\r\n\r\n\tlog10: function(num) {\r\n\t\treturn util.log(num, 10);\r\n\t},\r\n\t\r\n\tacosh: Math.acosh || function(num) {return Math.log(num + Math.sqrt(num * num - 1))},\r\n\r\n\tasinh: Math.asinh || function(num) {return num === -Infinity ? num : Math.log(num + Math.sqrt(num * num + 1))},\r\n\r\n\tatanh: Math.atanh || function(num) {return Math.log((1 + num)/(1 - num)) / 2},\r\n\r\n\t//可能存在浮点型精度问题\r\n\tcbrt: Math.cbrt || function(num) {return Math.pow(num, 1/3)}, \r\n\r\n\tsum: (...arg) => arg.reduce((s, v)=> s + v, 0),\r\n\r\n\tpow: Math.pow,\r\n\r\n\tfac: n => new Array(n+1).join('1').split('').reduce((s, v, i) => s*(i+1), 1),\r\n\r\n\tHCF: function hcf(a, b) {\r\n\t\treturn a%b ? hcf(b, a%b) : b;\r\n\t},\r\n\r\n\tangle2rad: n => n * 2 * Math.PI / 360,\r\n\r\n\trad2angle: n => n * 180 / Math.PI\r\n};\r\n// 对于JS中Math对象中有的方法进行替换， 没有的方法则自己实现\r\nlet replaceMethods = {\r\n\t\r\n\t'abs': Math.abs,\r\n\t'avg': util.avg,\r\n\t'sin': Math.sin,\r\n\t'cos': Math.cos,\r\n\t'tan': Math.tan,\r\n\t'cot': util.cot,\r\n\t'acos': Math.acos,\r\n\t'acosh': util.acosh,\r\n\t'asin': Math.asin,\r\n\t'atan': Math.atan,\r\n\t'asinh': util.asinh,\r\n\t'atanh': util.atanh,\r\n\t'atan2': Math.atan2,\r\n\t'logMutil' : util.log,\r\n\t'cbrt': util.cbrt,\r\n\t'sum': util.sum,\r\n\t'pow': util.pow,\r\n\t'fac': util.fac,\r\n\t'HCF': util.HCF,\r\n\t// ES6中Math对象上有等同性质的函数Math.log10\r\n\t//但是根据MDN(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/log10)\r\n\t//大多浏览器(新版本chrome上支持良好)不予支持, 故自己实现\r\n\t'log': util.log10,\r\n\t'ln': Math.log,\r\n\r\n\t// 常量\r\n\t'e': Math.E,\r\n\t'π': Math.PI\r\n};\r\n\r\n// 将方法中的三角函数类方法再加工，根据设置(status.isAngle)\r\n// 判断输入是角度还是弧度\r\n[\t'sin',\r\n\t'cos',\r\n\t'tan',\r\n\t'cot',\r\n\t'acos',\r\n\t'acosh', \r\n\t'asin',\r\n\t'atan',\r\n\t'asinh', \r\n\t'atanh', \r\n\t'atan2'  ].map(v => {\r\n\t\tvar oriFn = replaceMethods[v];\r\n\t\treplaceMethods[v] = n => status.isAngle ? oriFn(util.angle2rad(n)) : oriFn(n);\r\n\t});\r\n\r\n// 参数数量表 根据status.argModel判断是否是严格模式\r\n// 在普通模式下，参数过多忽略，参数过少会提醒。代码：0\r\n// 在严格模式时候，参数过多和参数过少都会提醒。 代码： 1\r\nlet argNum = {\r\n\t'abs': 1,\r\n\t'avg': 2, \r\n\t'sin': 1,\r\n\t'cos': 1,\r\n\t'tan': 1,\r\n\t'cot': 1,\r\n\t'acos': 1,\r\n\t'acosh': 1,\r\n\t'asin': 1,\r\n\t'atan': 1,\r\n\t'asinh': 1,\r\n\t'atanh': 1,\r\n\t'atan2': 1,\r\n\t'log': 1,\r\n\t'ln': 1,\r\n\t'logMutil' : 2,\r\n\t'cbrt': 1,\r\n\t'sum': 2,\r\n\t'pow': 2,\r\n\t'fac': 1,\r\n\t'HCF': 2\r\n};\r\n\r\n// 如果合法，返回true， 反之返回包含错误信息的字符串\r\nconst validVarible = (name, body) => {\r\n\tif(/^[a-z_]\\w*$/i.test(name) && /\\d+(\\.\\d+)?/.test(body)) {\r\n\t\treturn replaceMethods[name] ? '已经有同名常量或方法存在' : true;\r\n\t} else {\r\n\t\treturn /^[a-z_]\\w*$/i.test(name) ? '常量值不是数字！' : '不合法的常量名';\r\n\t}\r\n};\r\nconst createVarible = (name, body) => replaceMethods[name] = +body;\r\n\r\n\r\nconst validMethod = (name, body) => {\r\n\tif(!(/^[a-z_]\\w*$/i.test(name))) {\r\n\t\treturn '不合法的方法名';\r\n\t} else {\r\n\t\tif(replaceMethods[name]) return '已经有同名常量或方法存在';\r\n\t\telse {\r\n\t\t\t// 让方法体跑一遍，就知道其是不是合法的了\r\n\t\t\t// 这个replace可能与createMethod中的replace重复了\r\n\t\t\t// 某种意义上可以封装一下后复用\r\n\t\t\tlet res = caculate(body.replace(/\\s/g, '')\r\n\t\t\t\t\t\t\t\t\t.replace(/\\b[a-z_]\\w*(?!\\(|\\w)/g, v => replaceMethods[v] ? replaceMethods[v] : 1));\r\n\t\t\treturn typeof res === 'number' ? true : res;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nconst createMethod = (name, body) => {\r\n\r\n\t// 外部自定义方法调用\r\n\tvar arr = [];\r\n\tbody = body.replace(/\\s/g, '')\r\n\t\t\t\t.replace(/\\b[a-z_]\\w*(?!\\(|\\w)/g, v => {\r\n\t\t\t\t\tif(replaceMethods[v]) return replaceMethods[v];\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif(arr.indexOf(v) === -1) arr.push(v); \r\n\t\t\t\t\t\treturn v;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\targNum[name] = arr.length;\r\n\tfunction fn(...arg) {\r\n\t\tconsole.log(body.replace(RegExp(`\\\\b(${arr.join('|')})\\\\b`, 'g'), v => arg[arr.indexOf(v)] || v))\r\n\t\treturn body.replace(RegExp(`\\\\b(${arr.join('|')})\\\\b`, 'g'), v => arg[arr.indexOf(v)] || v);\r\n\t}\r\n\treplaceMethods[name] = bindArgNum(fn, arr.length, name);\r\n};\r\n\r\n\r\n// 根据参数数量表绑定参数，以提醒因参数导致的错误。\r\nconst bindArgNum = (fn, argNum, name) => {\r\n\treturn function(...arg) {\r\n\t\tif(arg.length < argNum) throw new Error(`传入${name}方法的参数过少`);\r\n\t\telse if(arg.length > argNum) {\r\n\t\t\tif(status.argModel === 0) return fn.apply(null, arg);\r\n\t\t\telse if(status.argModel === 1) throw new Error('传入${name}方法的参数过多');\r\n\t\t} else {\r\n\t\t\treturn fn.apply(null, arg);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//  绑定已有方法的参数数量\r\nfor(let key in argNum) {\r\n\treplaceMethods[key] = bindArgNum(replaceMethods[key], argNum[key], key);\r\n};\r\n\r\n// 把创建新常量和方法的函数 挂载在caculate上，方便外界调用\r\ncaculate.create = {\r\n\tvalidMethod: validMethod,\r\n\tcreateMethod: createMethod,\r\n\tvalidVarible: validVarible,\r\n\tcreateVarible: createVarible\r\n}\r\n\r\n// 暴露外界接口，可以改变status\r\ncaculate.changeModel = {\r\n\tchangeArgModel: () => status.argModel = +!status.argModel,\r\n\tchangeIsAngle: () => status.isAngle = !status.isAngle,\r\n\tchangeAllowVar: () => status.allowVar = !status.allowVar\r\n}\r\n\r\n\r\nmodule.exports = caculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/caculate.js\n// module id = 1\n// module chunks = 0"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;","sourceRoot":""}