{"version":3,"file":"main.min.js","sources":["webpack:///webpack/bootstrap 27a04ef45e9f5ff93a85","webpack:///./src/js/main.js","webpack:///./src/js/caculate.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 27a04ef45e9f5ff93a85","let cacu = require('./caculate.js');\r\n\r\nvar isRun = false;\r\n\r\nfunction caculate() {\r\n\tif(isRun) return;\r\n\tisRun = true;\r\n\tvar answer = $('.content-answer'),\r\n\t\tres = cacu($('.content-question').val());\r\n\tif(typeof res === 'number') {\r\n\t\tanswer.removeClass('error').addClass('correct');\r\n\t\tif(res !== res) answer.text('运算结果为: NaN, 无意义的运算').slideDown();\r\n\t\telse if(/Infinity/.test(res.toString())) answer.text('无穷：'+res.toString().replace(/Infinity/, 'n')).slideDown();\r\n\t\telse answer.text(`您的运算结果为：${res}`).slideDown();\r\n\t}\r\n\telse answer.removeClass('correct').addClass('error').text(res).slideDown();\r\n\tisRun = false;\r\n}\r\n\r\n\r\n$('.caculate-btn').click(caculate);\r\n\r\n$('.content-question').keyup(function(e) {\r\n\tif(e.keyCode === 13) caculate();\r\n\telse {\r\n\t\tif(!isRun) $('.content-answer').slideUp();\r\n\t}\r\n})\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/main.js\n// module id = 0\n// module chunks = 0","function caculate (str) {\r\n\tvar result;\r\n\tfunction innerCaculate (str) {\r\n\t\tvar ori = str,\r\n\t\t\tindex = 0,\r\n\t\t\tres;\r\n\t\t// 第一步  替换掉所有的空白类字符\r\n\t\tstr = str.replace(/\\s/g, '');\r\n\t\tif(!str) throw new Error('并没有输入任何有意义的运算');\r\n\t\t// 第二步  将常量名转换为常量值   π比较特殊，不算在\\w里面, 正则中另做处理\r\n\t\tstr = str.replace(/(\\b[a-z_]\\w*\\b|\\Bπ\\B)(?!\\()/gi, v => {\r\n\t\t\tif(!replaceMethods[v]) {\r\n\t\t\t\tthrow new Error(`不存在的常量名: ${v}`);\r\n\t\t\t} else if(replaceMethods[v] && typeof replaceMethods[v] !== 'number') {\r\n\t\t\t\tthrow new Error(`不能把方法: ${v} 当常量用`);\r\n\t\t\t} else {\r\n\t\t\t\treturn replaceMethods[v];\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// 第三步  将幂运算符及前后数值进行计算，转化为结果数值\r\n\t\t// 把^幂运算装换为pow方法  ^前后只能有单数字或常量，不能嵌套圆括号或者方法\r\n\t\t// 如果你想嵌套，可以使用pow\r\n\t\t// eg: (5+2) ^ Math.abs(2.4)   错误，报错“错误的使用: ^幂运算符”，请改用pow\r\n\t\t//     pow((5+2), Math.abs(2.4)) 正确\r\n\t\tstr = str.replace(/\\b(\\d(?:\\.\\d*)?)\\^((\\d(?:\\.\\d*)?))\\b/, (v, a, b) => Math.pow(a, b));\r\n\r\n\t\t// 第四步 在第三步替换掉幂运算符后如果还存在^， 代表其使用错误，报错。\r\n\t\tif(/\\^/.test(str)) throw new Error('错误的使用: ^幂运算符');\r\n\r\n\t\t// 第五步 处理方法或者圆括号内的内容, 将其转换为确切的数值.\r\n\t\twhile(/\\b([a-z_]\\w*)?\\([^(]*?\\)/i.test(str)) {\r\n\t\t\tstr = str.replace(/\\b([a-z_]\\w*)?\\(([^(]*?)\\)/i, (...arg) => {\r\n\t\t\t\tlet res, method = arg[1];\r\n\t\t\r\n\t\t\t\t// 如果没有匹配到方法名， 代表是纯运算式，直接eval求值。\r\n\t\t\t\tif(method === undefined) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tres = eval(arg[0])\r\n\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\tthrow new Error('不正确的算术格式~')\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet usage = replaceMethods[method];\r\n\t\t\t\t\tif(usage) {\r\n\t\t\t\t\t\t// 如果匹配到的方法名存在且是函数形式，则带参数求值\r\n\t\t\t\t\t\t// 不需要考虑参数数量限制， 这个判断逻辑放在replaceMethods的相应方法中\r\n\t\t\t\t\t\tif(usage instanceof Function) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tres = eval(`replaceMethods.${arg[1]}(${arg[2]})`);\r\n\t\t\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t\t\tthrow new Error('不正确的算术格式~');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if(typeof usage === 'number') {\r\n\t\t\t\t\t\t\tthrow new Error(`不能将常量 ${method} 当方法用`);\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 如果匹配到的方法名不存在，则报错\r\n\t\t\t\t\t\tthrow new Error(`不存在的方法名: ${method}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t});\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tres = eval(str);\r\n\t\t} catch(e) {\r\n\t\t\tthrow new Error('不正确的算术格式~');\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t// 捕获错误，并在catch中提示用户。\r\n\ttry {\r\n\r\n\t\tresult = innerCaculate(str);\r\n\r\n\t} catch(e) {\r\n\r\n\t\treturn e.message;\r\n\r\n\t}\r\n\t// 只精确到小数点后15位， 避免双浮点精度丢失\r\n\t// 15位防止Math.sin精度丢失 16位防止0.1+0.2这种情况\r\n\treturn +result.toFixed(15);\r\n};\r\n\r\n// 管理计算器的状态 \r\nlet status = {\r\n\tisAngle: true,\r\n\targModel: 0\r\n};\r\n\r\n// 一个储存自己数学方法的仓库\r\nlet util = {\r\n\tavg: (...arr) => util.sum.apply(null, arr) / arr.length,\r\n\r\n\tcot: num => Math.cos(num) / Math.sin(num),\r\n\t\r\n\tlog: (num1, num2) => Math.log(num1) / Math.log(num2),\r\n\r\n\tlog10: function(num) {\r\n\t\treturn util.log(num, 10);\r\n\t},\r\n\t\r\n\tacosh: Math.acosh || function(num) {return Math.log(num + Math.sqrt(num * num - 1))},\r\n\r\n\tasinh: Math.asinh || function(num) {return num === -Infinity ? num : Math.log(num + Math.sqrt(num * num + 1))},\r\n\r\n\tatanh: Math.atanh || function(num) {return Math.log((1 + num)/(1 - num)) / 2},\r\n\r\n\t//可能存在浮点型精度问题\r\n\tcbrt: Math.cbrt || function(num) {return Math.pow(num, 1/3)}, \r\n\r\n\tsum: (...arg) => arg.reduce((s, v)=> s + v, 0),\r\n\r\n\tpow: Math.pow,\r\n\r\n\tangle2rad: n => n * 2 * Math.PI / 360,\r\n\r\n\trad2angle: n => n * 180 / Math.PI\r\n};\r\n// 对于JS中Math对象中有的方法进行替换， 没有的方法则自己实现\r\nlet replaceMethods = {\r\n\t\r\n\t'abs': Math.abs,\r\n\t'avg': util.avg,\r\n\r\n\t'sin': Math.sin,\r\n\t'cos': Math.cos,\r\n\t'tan': Math.tan,\r\n\t'cot': util.cot,\r\n\t'acos': Math.acos,\r\n\t'acosh': util.acosh,\r\n\t'asin': Math.asin,\r\n\t'atan': Math.atan,\r\n\t'asinh': util.asinh,\r\n\t'atanh': util.atanh,\r\n\t'atan2': Math.atan2,\r\n\r\n\t// ES6中Math对象上有等同性质的函数Math.log10\r\n\t//但是根据MDN(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/log10)\r\n\t//大多浏览器(新版本chrome上支持良好)不予支持, 故自己实现\r\n\t'log': util.log10,\r\n\t'ln': Math.log,\r\n\r\n\t// 常量\r\n\t'e': Math.E,\r\n\t'π': Math.PI,\r\n\r\n\t\r\n\t'logMutil' : util.log,\r\n\t'cbrt': util.cbrt,\r\n\t'sum': util.sum,\r\n\t'pow': util.pow\r\n};\r\n\r\n// 将方法中的三角函数类方法再加工，根据设置(status.isAngle)\r\n// 判断输入是角度还是弧度\r\n[\t'sin',\r\n\t'cos',\r\n\t'tan',\r\n\t'cot',\r\n\t'acos',\r\n\t'acosh', \r\n\t'asin',\r\n\t'atan',\r\n\t'asinh', \r\n\t'atanh', \r\n\t'atan2'  ].map(v => {\r\n\t\tvar oriFn = replaceMethods[v];\r\n\t\treplaceMethods[v] = n => status.isAngle ? oriFn(util.angle2rad(n)) : oriFn(n);\r\n\t});\r\n\r\n// 参数数量表 根据status.argModel判断是否是严格模式\r\n// 在普通模式下，参数过多忽略，参数过少会提醒。代码：0\r\n// 在严格模式时候，参数过多和参数过少都会提醒。 代码： 1\r\nlet argNum = {\r\n\t'abs': 1,\r\n\t'avg': 'n', // 代表可以用n个参数;\r\n\t'sin': 1,\r\n\t'cos': 1,\r\n\t'tan': 1,\r\n\t'cot': 1,\r\n\t'acos': 1,\r\n\t'acosh': 1,\r\n\t'asin': 1,\r\n\t'atan': 1,\r\n\t'asinh': 1,\r\n\t'atanh': 1,\r\n\t'atan2': 1,\r\n\t'log': 1,\r\n\t'ln': 1,\r\n\t'logMutil' : 2,\r\n\t'cbrt': 1,\r\n\t'sum': 'n',\r\n\t'pow': 2\r\n};\r\n\r\n// 如果合法，返回true， 反之返回包含错误信息的字符串\r\nconst validVarible = (name, body) => {\r\n\tif(/^[a-z_]\\w*$/i.test(name) && /\\d+(\\.\\d+)?/.test(body)) {\r\n\t\treturn replaceMethods[name] ? '已经有同名常量或方法存在' : true;\r\n\t} else {\r\n\t\treturn /^[a-z_]\\w*$/i.test(name) ? '常量值不是数字！' : '不合法的常量名';\r\n\t}\r\n};\r\nconst createVarible = (name, body) => replaceMethods[name] = +body;\r\n\r\n\r\nconst validMethod = (name, body) => {\r\n\tif(!(/^[a-z_]\\w*$/i.test(name))) {\r\n\t\treturn '不合法的方法名';\r\n\t} else {\r\n\r\n\t}\r\n};\r\nconst createMethod = (name, body, argNum) => {\r\n\tif(typeof body === 'string') {\r\n\t\tvar arr = [];\r\n\t\tbody = body.replace(/\\s/g, '');\r\n\t\tbody = body.replace(/\\b[a-z_]\\w*(?!\\()/g, v => {\r\n\t\t\tif(replaceMethods[v]) return replaceMethods[v];\r\n\t\t\telse {\r\n\t\t\t\tif(arr.indexOf(v) === -1) arr.push(v); \r\n\t\t\t\treturn v;\r\n\t\t\t}\r\n\t\t});\r\n\t\targNum[name] = arr.length;\r\n\t\treturn function fn(...arg) {\r\n\t\t\treturn body.replace(RegExp(`\\\\b(${arr.join('|')})\\\\b`, 'g'), v => arg[arr.indexOf(v)]);\r\n\t\t}\r\n\t} else {\r\n\t\treturn function(...arg) {\r\n\t\t\tif(arg.length < argNum) throw new Errow(`传入${name}方法的参数过少`);\r\n\t\t\telse if(arg.length > argNum) {\r\n\t\t\t\tif(status.argModel === 0) return body.apply(null, arg);\r\n\t\t\t\telse if(status.argModel === 1) throw new Error('传入${name}方法的参数过多');\r\n\t\t\t} else {\r\n\t\t\t\treturn body.apply(null, arg);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n//  绑定已有方法的参数数量\r\nfor(let key in argNum) {\r\n\treplaceMethods[key] = createMethod(key, replaceMethods[key], argNum[key]);\r\n};\r\n\r\n\r\n\r\nmodule.exports = caculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/caculate.js\n// module id = 1\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;","sourceRoot":""}