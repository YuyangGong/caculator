{"version":3,"file":"main.min.js","sources":["webpack:///webpack/bootstrap 6a0b5b223fb9021fcdf7","webpack:///./src/js/core.js","webpack:///./src/js/util.js","webpack:///./src/js/status.js","webpack:///./src/js/constants.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6a0b5b223fb9021fcdf7","let util = require('./util.js'),\r\n\tconstants = require('./constants.js'),\r\n\tstatus = require('./status.js');\r\n\r\n// 处理运算符\r\nlet op = {\r\n\t'+': (a, b) => +a + +b,\r\n\t'-': (a, b) => a - b,\r\n\t'*': (a, b) => a * b,\r\n\t'/': (a, b) => a / b,\r\n\t'%': (a, b) => a % b,\r\n\t'^': (a, b) => Math.pow(a, b)\r\n}\r\n// 比较运算符的优先级\r\nconst compareLevel = (a, b) => {\r\n\tvar levelMap = {\r\n\t\t'(': 4,\r\n\t\t'^': 3,\r\n\t\t'*': 2,\r\n\t\t'/': 2,\r\n\t\t'%': 1,\t\r\n\t\t'+': 0,\r\n\t\t'-': 0\t\r\n\t};\r\n\treturn levelMap[a] > levelMap[b];\t\r\n}\r\n\r\nlet isNum = n => /^[+\\-]?\\d+(\\.\\d*)?$/.test(n);\r\nlet isMethodName = n => /^[a-z][a-z\\d]*$/i.test(n);\r\nlet isOperate = n => /^[+\\-\\*/^%(,]$/.test(n);\r\nlet isBlank = n => /\\s/.test(n);\r\nlet isConstant = n => !!constants[n];\r\nlet isMethod = n => !!util[n];\r\n\r\n// 主要处理逻辑, 传入运算字符串，返回运算结果 或者 包含错误信息的数组。\r\nfunction caculate(str) {\r\n\tlet res;\r\n\tfunction innerCaculate(str, start = 0) {\r\n\t\tlet len = str.length,\r\n\t\t\topStack = [],\r\n\t\t\tvalueStack = [],\r\n\t\t\tlastValue = '',\r\n\t\t\tspaceLen = 0,\r\n\t\t\tcurChar,\r\n\t\t\tisFirstOp;\r\n\t\tfor(var pos = 0; pos < len; pos++) {\r\n\r\n\t\t\tcurChar = str[pos];\r\n\r\n\r\n\t\t\t// 如果是π\r\n\t\t\t// 其前面只能为运算符, 右括号, 逗号, 或者什么都不跟, 遇到其他情况就报错。\r\n\t\t\t// 如果是以正负号开头, 则应该当做π的前缀运算符\r\n\t\t\tif(curChar === 'π') {\r\n\t\t\t\tif(/[(,+\\-*/%^]/.test(lastValue)) {\r\n\t\t\t\t\tif(/[\\-+]/.test(lastvalue) && isFirstOp) {\r\n\t\t\t\t\t\tisFirstOp = false;\r\n\t\t\t\t\t\tlastValue += 'π';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlastValue = 'π';\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(lastValue === '') {\r\n\t\t\t\t\tlastValue = 'π';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`18, π, ${pos}`);\r\n\t\t\t\t}\r\n\t\t\t\tspaceLen = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// 如果是空格类\r\n\t\t\t// 有很多可能\r\n\t\t\t// 1. 存在最前面的或前面还有空格的空格 可以忽略， 判断条件,lastValue没有值 \r\n\t\t\t// 2. 其他情况则用spaceLen++, 来监控space的数量\r\n\t\t\t// 不额外处理，某种意义上就像忽略了空格\r\n\t\t\telse if(isBlank(curChar)) {\r\n \t\t\t\tif(lastValue === '') {\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\t}\r\n \t\t\t\tspaceLen++;\r\n\t\t\t}\t\t\t\r\n\r\n\t\t\t// 如果是数字的话，可能是方法名或常量名的一部分，也可能是数字的一部分\r\n\t\t\t// 如果数字之前有空格隔开的变量或者常量的话，那么应该报错，如 (12 12)这种表达式\r\n\t\t\t// 其不能跟在右括号\")\"后面\r\n\t\t\telse if(/\\d/.test(curChar)) {\r\n\t\t\t\tif(isNum(lastValue) || isMethodName(lastValue)) {\r\n\t\t\t\t\t// 数字间不合法的空格，报错。如(123 123)\r\n\t\t\t\t\tif(spaceLen) throw new Error(`53, ${curChar}, ${pos}`);\r\n\t\t\t\t\tlastValue += curChar;\r\n\t\t\t\t} else if(isOperate(lastValue)) {\r\n\t\t\t\t\tif(isFirstOp && /[+\\-]/.test(lastValue)) {\r\n\t\t\t\t\t\tisFirstOp = false;\r\n\t\t\t\t\t\tlastValue += curChar;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlastValue = curChar;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(lastValue === '') {\r\n\t\t\t\t\tlastValue = curChar;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`19, ${curChar}, ${pos}`)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tspaceLen = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// 如果是小数点\r\n\t\t\t// 前面已经有小数点的数字，或者不是数字都理应报错\r\n\t\t\t// 如果前面是还没有存在小数点的数字，应该加上去\r\n\t\t\telse if(/\\./.test(curChar)) {\r\n\t\t\t\tif(/^[+\\-]?\\d+$/.test(lastValue) && !spaceLen) {\r\n\t\t\t\t\tlastValue += '.';\r\n\t\t\t\t} else if(isNum(lastValue)) {\r\n\t\t\t\t\tthrow new Error(`51, ., ${pos}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`52, ., ${pos}`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 如果是字母的话，只能是方法名或者常量名的一部分\r\n\t\t\telse if(isMethodName(curChar)) {\r\n\t\t\t\tif(/^[a-z\\d]+$/i.test(lastValue)) {\r\n\t\t\t\t\tif(spaceLen) throw new Error(`53, ${curChar}, ${pos - spaceLen}`);\t\r\n\t\t\t\t\tif(/^\\d$/.test(lastValue)) throw new Error(`33, ${lastValue}, ${pos - 1}`);\r\n\t\t\t\t\tlastValue += curChar;\r\n\t\t\t\t} else if(isOperate(lastValue) || lastValue === '') {\r\n\t\t\t\t\tif(isFirstOp && /[+\\-]/.test(lastValue)) {\r\n\t\t\t\t\t\tisFirstOp = false;\r\n\t\t\t\t\t\tlastValue += curChar;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse lastValue = curChar;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`61, ${curChar}, ${pos}`);\r\n\t\t\t\t}\r\n\t\t\t\tspaceLen = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// 如果是右圆括号的话, 只能跟在'(', ',' '' 变量名的后面\r\n\t\t\telse if(curChar === '(') {\r\n\t\t\t\tif(/^\\(|,$/.test(lastValue) || lastValue === '') {\r\n\t\t\t\t\topStack.unshift(curChar);\t\r\n\t\t\t\t} else if(isOperate(lastValue)) {\r\n\t\t\t\t\tif(isFirstOp && /^[+\\-]$/.test(lastValue)) {\r\n\t\t\t\t\t\tisFirstOp = false;\r\n\t\t\t\t\t\topStack.unshift(lastValue + curChar);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\topStack.unshift(curChar);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(isMethodName(lastValue)) {\r\n\t\t\t\t\tif(isMethod(lastValue)) {\r\n\t\t\t\t\t\topStack.unshift(lastValue + curChar);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error(`32, ${lastValue}, ${pos - spaceLen - lastValue.length}`)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`14, ${curChar}, ${pos}`);\r\n\t\t\t\t}\r\n\t\t\t\tlastValue = curChar;\r\n\t\t\t\tspaceLen = 0;\r\n\t\t\t}\r\n\r\n\t\t\telse if(curChar === ',') {\r\n\t\t\t\tif(!opStack.some(v => /\\(/.test(v))) throw new Error(`15, ${curChar}, ${pos}`);\r\n\t\t\t\tif(isMethodName(lastValue) || isNum(lastValue) || /^(π|\\))$/.test(lastValue)) {\r\n\t\t\t\t\tif(isMethodName(lastValue) || lastValue === 'π') {\r\n\t\t\t\t\t\tif(!isConstant(lastValue)) {\r\n\t\t\t\t\t\t\tthrow new Error(`31, ${lastValue}, ${pos - spaceLen - lastValue.length}`);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalueStack.unshift(constants[lastValue]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if(isNum(lastValue)) {\r\n\t\t\t\t\t\tvalueStack.unshift(lastValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile( opStack.length && !(/[(,]/.test(opStack[0]))) {\r\n\t\t\t\t\t\tlet num2 = valueStack.shift(), \r\n\t\t\t\t\t\t\tnum1 = valueStack.shift();\r\n\t\t\t\t\t\tvalueStack.unshift(op[opStack.shift()](num1, num2));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`15, ${curChar}, ${pos}`)\r\n\t\t\t\t}\r\n\t\t\t\topStack.unshift(curChar);\r\n\t\t\t\tlastValue = curChar;\r\n\t\t\t\tspaceLen = 0;\r\n\t\t\t}\r\n\r\n\t\t\telse if(curChar === ')') {\r\n\t\t\t\tif(isNum(lastValue) || isMethodName(lastValue) || /(π|\\))$/.test(lastValue)) {\r\n\t\t\t\t\tif(isNum(lastValue)) {\r\n\t\t\t\t\t\tvalueStack.unshift(lastValue);\t\t\t\t\t\t\r\n\t\t\t\t\t} else if(lastValue !== ')') {\r\n\t\t\t\t\t\tif(!isConstant(lastValue)) throw new Error(`31, ${lastValue}, ${pos - spaceLen - lastValue.length}`);\r\n\t\t\t\t\t\tvalueStack.unshift(constants[lastValue]);\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet arg = [];\r\n\t\t\t\t\tif(!opStack.some(v => /\\(/.test(v))) {\r\n\t\t\t\t\t\tthrow new Error(`16, ${curChar}, ${pos}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile(1) {\r\n\t\t\t\t\t\tif(/^[+\\-*/%^]$/.test(opStack[0])) {\r\n\t\t\t\t\t\t\tvalueStack.unshift(op[opStack.shift()].apply(null, [valueStack.shift(), valueStack.shift()].reverse()));\r\n\t\t\t\t\t\t} else if(/^,$/.test(opStack[0])) {\r\n\t\t\t\t\t\t\topStack.shift();\r\n\t\t\t\t\t\t\targ.unshift(+valueStack.shift());\r\n\t\t\t\t\t\t} else if(/\\($/.test(opStack[0])) {\r\n\t\t\t\t\t\t\tlet isPositive = /[+\\-]/.test(opStack[0][0]) ? opStack[0][0] === '+' : true;\r\n\t\t\t\t\t\t\tif(/[+\\-]/.test(opStack[0][0])) opStack[0] = opStack[0].slice(1);\r\n\t\t\t\t\t\t\targ.unshift(+valueStack.shift());\r\n\t\t\t\t\t\t\tif(opStack[0].length !== 1) {\r\n\t\t\t\t\t\t\t\ttry { \r\n\t\t\t\t\t\t\t\t\tvalueStack.unshift(util[opStack[0].slice(0, -1)].apply(null, arg) * (isPositive? 1:-1));\r\n\t\t\t\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t\t\t\tthrow new Error(`${e.message}, ${pos}`);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvalueStack.unshift(arg.pop() * (isPositive? 1:-1));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\topStack.shift();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow(`unknow Error`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 去掉左括号后，计算之前的运算\r\n\t\t\t\t\twhile( opStack.length && !(/\\(|,/.test(opStack[0]))) {\r\n\t\t\t\t\t\tlet num2 = valueStack.shift(), \r\n\t\t\t\t\t\t\tnum1 = valueStack.shift();\r\n\t\t\t\t\t\tvalueStack.unshift(op[opStack.shift()](num1, num2));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if(lastValue === '(') {\r\n\t\t\t\t\tif(opStack[0].length !== 1) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tvalueStack.unshift(util[opStack[0].slice(0, -1)]());\r\n\t\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t\tthrow new Error(`${e.message}, ${pos}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\topStack.shift();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`16, ${curChar}, ${pos}`);\r\n\t\t\t\t}\r\n\t\t\t\tlastValue = curChar;\r\n\t\t\t\tspaceLen = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// 如果是运算符\r\n\t\t\telse if(isOperate(curChar)) {\r\n\t\t\t\t// 当表达式第一位是运算符的时候就应该报错, 如表达式*3+2或3+(%3)\r\n\t\t\t\t// 当运算符前面的lastValue不是数值,变量名或者右圆括号)的时候应该报错\r\n\t\t\t\t// 但是有例外， 比如-2+3, 又或者3+(-2),这应该是合法的表达式\r\n\t\t\t\t// 这时候，应该改变外部变量isFirstOp为true, 并且不报错。\r\n\t\t\t\t// 然后等遍历到后续的数字，将带有前置符的数字入栈\r\n\t\t\t\tif(/^\\(?,?$/.test(lastValue) || lastValue === '') {\r\n\t\t\t\t\tif(/[+\\-]/.test(curChar)) {\r\n\t\t\t\t\t\tisFirstOp = true;\r\n\t\t\t\t\t\tlastValue = curChar;\r\n\t\t\t\t\t\tspaceLen = 0;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error(`12, ${curChar}, ${start + pos}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 结算前面的lastValue\r\n\t\t\t\t// lastValue的可能性是(PS: \\s类字符已遍历时忽略) \r\n\t\t\t\t// 1. 数字, 入valueStack栈\r\n\t\t\t\t// 2. 常量, 计算其值后入valueStack栈, 如果不存在这个常量就报错\r\n\t\t\t\t// 3. 右括号 ) , 这种情况什么都不做，在遍历到右括号时候处理\r\n\t\t\t\t// 如果不是上面俩种可能，则代表此运算符前还是运算符,报错\r\n\t\t\t\telse if(isNum(lastValue)) {\r\n\t\t\t\t\tvalueStack.unshift(lastValue);\r\n\t\t\t\t} else if(isMethodName(lastValue) || lastValue === 'π') {\r\n\t\t\t\t\tif(isConstant(lastValue)) {\r\n\t\t\t\t\t\tvalueStack.unshift(constants[lastValue]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error(`31, ${lastValue}, ${pos - lastValue.length - spaceLen}`)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(lastValue !== ')') {\r\n\t\t\t\t\tthrow new Error(`41, ${curChar}, ${pos}`);\r\n\t\t\t\t}\r\n\t\t\t\t// 判断栈中内容\r\n\t\t\t\t// 如果运算符优先级不大于栈顶，则出运算符栈栈顶的运算符\r\n\t\t\t\t// 再出 运算值栈栈顶的俩个元素， 进行运算\r\n\t\t\t\t// 将运算结果推入 运算值栈栈顶\r\n\t\t\t\t// 然后继续判断优先级， \r\n\t\t\t\t// 直到满足一下条件\r\n\t\t\t    // 1. 运算符栈有元素\r\n\t\t\t\t// 2. 目前的优先级不高于栈顶\r\n\t\t\t\t// 3. 栈顶不是逗号或者圆括号：, (\r\n\t\t\t\t// 运算符的可能性： + - * / % ^ ( ) ,\r\n\t\t\t\twhile( opStack.length \r\n\t\t\t\t\t   && !(/\\(|,/.test(opStack[0])) \r\n\t\t\t\t\t   && !compareLevel(curChar, opStack[0]) ) {\r\n\t\t\t\t\tlet num2 = valueStack.shift(), \r\n\t\t\t\t\t\tnum1 = valueStack.shift();\r\n\t\t\t\t\tvalueStack.unshift(op[opStack.shift()](num1, num2));\r\n\t\t\t\t}\r\n\t\t\t\t// 将目前的运算符推入栈顶\r\n\t\t\t\topStack.unshift(curChar);\r\n\t\t\t\tlastValue = curChar;\r\n\t\t\t\tspaceLen = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// 如果以上都不是，那只能直接报错了。\r\n\t\t\t// 错误代码11, 表示无法识别的字符\r\n\t\t\telse {\r\n\t\t\t\tthrow new Error(`11, ${cur}, ${start+pos}`);\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\tif(isOperate(lastValue)) {\r\n\t\t\tthrow new Error(`17, ${lastValue}, ${len - 1 - spaceLen}`)\r\n\t\t} else if(isNum(lastValue)) {\r\n\t\t\tvalueStack.unshift(lastValue);\r\n\t\t} else if(isMethodName(lastValue) || lastValue === 'π') {\r\n\t\t\tif(!isConstant(lastValue))throw new Error(`17, ${lastValue}, ${pos - 1 - spaceLen}`);\r\n\t\t\telse valueStack.unshift(constants[lastValue]);\r\n\t\t}\r\n\r\n\t\twhile(opStack.length && !(/\\(,/.test(opStack[0]))) {\r\n\t\t\tlet num2 = valueStack.shift(), \r\n\t\t\t\tnum1 = valueStack.shift();\r\n\t\t\tvalueStack.unshift(op[opStack.shift()](num1, num2));\r\n\t\t}\r\n\r\n\t\tif(!opStack.length && valueStack.length === 1) return valueStack[0];\r\n\t\telse throw new Error(`71`);\r\n\t}\r\n\r\n\ttry {\r\n\t\tres = innerCaculate(str);\r\n\t} catch(e) {\r\n\t\tres = e.message.split(/\\s*,\\s*/);\r\n\t}\r\n\t// 如果结果是数字则返回数字， 如果结果是错误字符串，则解析成数组\r\n\t// 错误字符串解析成数组后，\r\n\t// 第一个元素表示错误代码\r\n\t// 第二个元素表示错误字符或方法常量名\r\n\t// 第三个元素表示错误所在的位置索引\r\n\treturn typeof res === 'Object' ? res : +(+res).toFixed(15);\r\n}\r\n\r\n// 如果合法，返回true， 反之返回包含错误信息的字符串\r\nconst validVarible = (name, value) => {\r\n\tif(/^[a-z][a-z\\d]*$/i.test(name) && isNum(value)) {\r\n\t\treturn constants[name] ? [81] : true;\r\n\t} else {\r\n\t\treturn /^[a-z_]\\w*$/i.test(name) ? [83] : [82];\r\n\t}\r\n};\r\n\r\nconst createVarible = (name, value) => constants[name] = +value;\r\n\r\nconst validMethod = (name, body) => {\r\n\tif(!(/^[a-z][a-z\\d]*$/i.test(name))) {\r\n\t\treturn [85];\r\n\t} else {\r\n\t\tif(util[name]) return [84];\r\n\t\telse {\r\n\t\t\t// 让方法体跑一遍，就知道其是不是合法的了\r\n\t\t\t// 这个replace可能与createMethod中的replace重复了\r\n\t\t\t// 某种意义上可以封装一下后复用\r\n\t\t\tlet res = caculate(body.replace(/\\s/g, '')\r\n\t\t\t\t\t\t\t\t\t.replace(/\\b[a-z][a-z\\d]*(?!\\(|\\w)/ig, v => util[v] ? util[v] : 1));\r\n\t\t\treturn typeof res === 'number' ? true : res;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\nconst createMethod = (name, body) => {\r\n\r\n\t// 外部自定义方法调用\r\n\tvar arr = [],\r\n\t\tisArgStrict = status.isArgStrict;\r\n\tbody = body.replace(/\\s/g, '')\r\n\t\t\t\t.replace(/\\b[a-z][a-z\\d]*(?!\\(|\\w)/g, v => {\r\n\t\t\t\t\tif(util[v]) return util[v];\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif(arr.indexOf(v) === -1) arr.push(v); \r\n\t\t\t\t\t\treturn v;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\tfunction fn(...arg) {\r\n\t\tvar res;\r\n\t\tif(arg.length < arr.length) {\r\n\t\t\tthrow new Error(`21, ${key}`);\r\n\t\t} else if(arg.length > arr.length) {\r\n\t\t\tif(isArgStrict) throw new Error(`22, ${key}`);\r\n\t\t}\r\n\t\tres = caculate(body.replace(RegExp(`\\\\b(${arr.join('|')})\\\\b`, 'g'), v => arg[arr.indexOf(v)] || v));\r\n\t\tif(typeof res !== 'number') throw new Error(`unknow error at custom method`);\r\n\t\treturn res;\r\n\t}\r\n\tutil[name] = fn;\r\n};\r\n\r\n\r\n// 将 改变模式 和 创建新方法或常量 的接口挂载在caculate函数上\r\ncaculate.create = {\r\n\tvalidMethod: validMethod,\r\n\tcreateMethod: createMethod,\r\n\tvalidVarible: validVarible,\r\n\tcreateVarible: createVarible\r\n}\r\n\r\ncaculate.changeModel = {\r\n\tchangeArgModel: () => status.isArgStrict = +!status.isArgStrict,\r\n\tchangeIsAngle: () => status.isAngle = !status.isAngle\r\n}\r\n\r\nmodule.exports = caculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/core.js\n// module id = 0\n// module chunks = 0","var status = require('./status.js')\r\n\r\n// math method\r\nvar util = {\r\n\t\r\n\t'abs': Math.abs,\r\n\r\n\t'avg': (...arr) => util.sum.apply(null, arr) / arr.length,\r\n\r\n\t'sin': Math.sin,\r\n\r\n\t'cos': Math.cos,\r\n\r\n\t'tan': Math.tan,\r\n\r\n\t'cot': num => Math.cos(num) / Math.sin(num),\r\n\r\n\t'acos': Math.acos,\r\n\r\n\t'acosh': Math.acosh || function(num) {return Math.log(num + Math.sqrt(num * num - 1))},\r\n\r\n\t'asin': Math.asin,\r\n\r\n\t'atan': Math.atan,\r\n\r\n\t'asinh': Math.asinh || function(num) {return num === -Infinity ? num : Math.log(num + Math.sqrt(num * num + 1))},\r\n\r\n\t'atanh': Math.atanh || function(num) {return Math.log((1 + num)/(1 - num)) / 2},\r\n\r\n\t'atan2': Math.atan2,\r\n\r\n\t'logMutil' : (num1, num2) => Math.log(num1) / Math.log(num2),\r\n\r\n\t'cbrt': Math.cbrt || function(num) {return Math.pow(num, 1/3)},\r\n\r\n\t'sum': (...arg) => arg.reduce((s, v)=> s + v, 0),\r\n\r\n\t'pow': Math.pow,\r\n\r\n\t'fac': n => new Array(n+1).join('1').split('').reduce((s, v, i) => s*(i+1), 1),\r\n\r\n\t'HCF': function hcf(a, b) {\r\n\t\treturn a%b ? hcf(b, a%b) : b;\r\n\t},\r\n\r\n\r\n\t'log': Math.log10 || function(num) {util.log(num, 10)},\r\n\r\n\t'ln': Math.log,\r\n\r\n\t// change between angle and radian\r\n\tangle2rad: n => n * 2 * Math.PI / 360,\r\n\trad2angle: n => n * 180 / Math.PI\r\n};\r\n\r\n\r\n// a map for check number of arguments.\r\nlet argNumbers = {\r\n\t'abs': 1,\r\n\t'avg': 2, \r\n\t'sin': 1,\r\n\t'cos': 1,\r\n\t'tan': 1,\r\n\t'cot': 1,\r\n\t'acos': 1,\r\n\t'acosh': 1,\r\n\t'asin': 1,\r\n\t'atan': 1,\r\n\t'asinh': 1,\r\n\t'atanh': 1,\r\n\t'atan2': 1,\r\n\t'log': 1,\r\n\t'ln': 1,\r\n\t'logMutil' : 2,\r\n\t'cbrt': 1,\r\n\t'sum': 2,\r\n\t'pow': 2,\r\n\t'fac': 1,\r\n\t'HCF': 2\r\n};\r\n\r\n// a trigonometry function map for next wrap function \r\nlet trigonometry = [\t'sin',\r\n\t\t\t\t\t\t'cos',\r\n\t\t\t\t\t\t'tan',\r\n\t\t\t\t\t\t'cot',\r\n\t\t\t\t\t\t'acos',\r\n\t\t\t\t\t\t'acosh', \r\n\t\t\t\t\t\t'asin',\r\n\t\t\t\t\t\t'atan',\r\n\t\t\t\t\t\t'asinh', \r\n\t\t\t\t\t\t'atanh', \r\n\t\t\t\t\t\t'atan2'    ];\r\n\r\n// wrap util method \r\n// 1. check arguments number\r\n// 2. if the method is trigonometry function, judge the status.isAngle\r\nfor(let key in argNumbers) {\t\r\n\tlet oriFn = util[key],\r\n\t\targNum = argNumbers[key],\r\n\t\tisTrigonometry;\r\n\t\r\n\tutil[key] = function(...arg) {\r\n\t\tlet len = arg.length,\r\n\t\t\tisAngle = status.isAngle,\r\n\t\t\tisArgStrict = status.isArgStrict;\r\n\t\t// throw new Error if arguments number not match\r\n\t\t// error string will present like 'errCode, methodName'\r\n\t\tif(len < argNum) {\r\n\t\t\t// if the actual arguments less than require arguments number\r\n\t\t\tthrow new Error(`21, ${key}`);\r\n\t\t} else if(len > argNum) {\r\n\t\t\tif(isArgStrict) {\r\n\t\t\t\tthrow new Error(`22, ${key}`);\r\n\t\t\t}\r\n\t\t}\r\n\t\tisTrigonometry = trigonometry.indexOf(key) > -1;\r\n\t\treturn oriFn.apply(null, isTrigonometry && isAngle ? arg.map(v => util.angle2rad(v)) : arg); \r\n\t}\r\n\t\r\n\r\n\t// mount the arguments number on function\r\n\tutil[key].argNum = argNum;\r\n\r\n}\r\n\r\n\r\nmodule.exports = util;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/util.js\n// module id = 1\n// module chunks = 0","let status = {\r\n\tisAngle: true,\r\n\tisArgStrict: false\r\n};\r\n\r\nmodule.exports = status;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/status.js\n// module id = 2\n// module chunks = 0","var constants =  {\r\n\t'e': Math.E,\r\n\t'π': Math.PI\r\n};\r\n\r\nmodule.exports = constants;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/constants.js\n// module id = 3\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACjaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;;","sourceRoot":""}