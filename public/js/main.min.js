/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	let cacu = __webpack_require__(1),
		errorMessage = __webpack_require__(5);

	var create = cacu.create;

	// 处理运算
	function dealCacu(input, resultDiv) {
		var	res = cacu(input.val()), 
			errorIndex,
			isSuccess;
		if(typeof res === 'number') {
			isSuccess = true;
			if(res !== res) res = '运算结果为: NaN, 无意义的运算';
			else if(/Infinity/.test(res.toString())) res = '无穷：'+res.toString().replace(/Infinity/, 'n');
			else res = `您的运算结果为：${res}`;
		} else {
			errorIndex = res[2];
			res = `${errorMessage[res[0]]} : ${res[1]}`;
			isSuccess = false;
		}
		showRes(resultDiv, isSuccess, res, errorIndex);
	}

	// 处理新建常量
	function createConstant(input, resultDiv) {
		var name = input.eq(0).val(),
			value = input.eq(1).val(),
			res = create.validVarible(name, value);
		if(res === true) {
			create.createVarible(name, value);
			showRes(resultDiv, true, `创建成功！常量名:${name} 常量值:${value}`);
		} else {
			res = errorMessage[res];
			showRes(resultDiv, false, res);
		}
	}

	// 处理新建方法
	function createMethod(input, resultDiv) {
		var name = input.eq(0).val(),
			value = input.eq(1).val(),
			res = create.validMethod(name, value);
		if(res === true) {
			create.createMethod(name, value);
			showRes(resultDiv, true, `创建成功！方法名:${name} 方法体:${value}`);
		} else {
			res = errorMessage[res];
			showRes(resultDiv, false, res);
		}
	}

	// 显示结果
	function showRes(resultDiv, isSuccess, message, errorIndex) {
		if(isSuccess) resultDiv.removeClass('error').addClass('correct');
		else {
			resultDiv.removeClass('correct').addClass('error');
			if(errorIndex !== undefined) {
				let offset = $('.content-question').offset();
				console.log(offset);
				$('#arrow').css({
					left: offset.left + 34 + errorIndex*11,
					marginTop: offset.top - 30
				}).show();
			}
		}
		resultDiv.text(message).slideDown('slow');
	}

	// 获得结果， 封装的一个处理计算 和 创建常量及方法的函数
	function getRes(elem) {
		var parent = elem.parent(), 
			input = elem.siblings('input'),
			resultDiv = elem.siblings('.result');
		if(parent.hasClass('content')) {
		// 处理运算
			dealCacu(input, resultDiv);
		} else if(parent.hasClass('constant')){
		// 处理新建常量
			createConstant(input, resultDiv);
		} else {
		// 处理新建方法
			createMethod(input, resultDiv);
		}
	}

	// 绑定按钮的点击事件
	$('button').click(function() {
		getRes($(this));
	});

	// 绑定按键事件，按回车的时候相当于点击按钮， 按其他键的时候则隐藏结果
	$('input').keyup(function(e) {
		if(e.keyCode === 13) {
			getRes($(this).parent().find('button'));
		} else {
			$('.result').slideUp('slow');
			$('#arrow').hide();
		}
	});

	$('input').click(function(){
		$('.result').slideUp('slow');
		$('#arrow').hide();
	})

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	let util = __webpack_require__(2),
		constants = __webpack_require__(4),
		status = __webpack_require__(3);

	// 处理运算符
	let op = {
		'+': (a, b) => +a + +b,
		'-': (a, b) => a - b,
		'*': (a, b) => a * b,
		'/': (a, b) => a / b,
		'%': (a, b) => a % b,
		'^': (a, b) => Math.pow(a, b)
	}
	// 比较运算符的优先级
	const compareLevel = (a, b) => {
		var levelMap = {
			'(': 4,
			'^': 3,
			'*': 2,
			'/': 2,
			'%': 1,	
			'+': 0,
			'-': 0	
		};
		return levelMap[a] > levelMap[b];	
	}

	let isNum = n => /^[+\-]?\d+(\.\d*)?$/.test(n);
	let isMethodName = n => /^[a-z][a-z\d]*$/i.test(n);
	let isOperate = n => /^[+\-\*/^%(,]$/.test(n);
	let isBlank = n => /\s/.test(n);
	let isConstant = n => !!constants[n];
	let isMethod = n => !!util[n];

	// 主要处理逻辑, 传入运算字符串，返回运算结果 或者 包含错误信息的数组。
	function caculate(str) {
		let res;
		function innerCaculate(str) {
			let len = str.length,
				opStack = [],
				valueStack = [],
				lastValue = '',
				spaceLen = 0,
				curChar,
				isFirstOp;
			for(var pos = 0; pos < len; pos++) {

				curChar = str[pos];
				console.log(curChar);

				// 如果是π
				// 其前面只能为运算符, 右括号, 逗号, 或者什么都不跟, 遇到其他情况就报错。
				// 如果是以正负号开头, 则应该当做π的前缀运算符
				if(curChar === 'π') {
					if(/[(,+\-*/%^]/.test(lastValue)) {
						if(/[\-+]/.test(lastvalue) && isFirstOp) {
							isFirstOp = false;
							lastValue += 'π';
						} else {
							lastValue = 'π';
						}
					} else if(lastValue === '') {
						lastValue = 'π';
					} else {
						throw new Error(`18, π, ${pos}`);
					}
					spaceLen = 0;
				}

				// 如果是空格类
				// 有很多可能
				// 1. 存在最前面的或前面还有空格的空格 可以忽略， 判断条件,lastValue没有值 
				// 2. 其他情况则用spaceLen++, 来监控space的数量
				// 不额外处理，某种意义上就像忽略了空格
				else if(isBlank(curChar)) {
	 				if(lastValue === '') {
	 					continue;
	 				}
	 				spaceLen++;
				}			

				// 如果是数字的话，可能是方法名或常量名的一部分，也可能是数字的一部分
				// 如果数字之前有空格隔开的变量或者常量的话，那么应该报错，如 (12 12)这种表达式
				// 其不能跟在右括号")"后面
				else if(/\d/.test(curChar)) {
					if(isNum(lastValue) || isMethodName(lastValue)) {
						// 数字间不合法的空格，报错。如(123 123)
						if(spaceLen) throw new Error(`53, ${curChar}, ${pos}`);
						lastValue += curChar;
					} else if(isOperate(lastValue)) {
						if(isFirstOp && /[+\-]/.test(lastValue)) {
							isFirstOp = false;
							lastValue += curChar;
						} else {
							lastValue = curChar;
						}
					} else if(lastValue === '') {
						lastValue = curChar;
					} else {
						throw new Error(`19, ${curChar}, ${pos}`)
					}

					spaceLen = 0;
				}

				// 如果是小数点
				// 前面已经有小数点的数字，或者不是数字都理应报错
				// 如果前面是还没有存在小数点的数字，应该加上去
				else if(/\./.test(curChar)) {
					if(/^[+\-]?\d+$/.test(lastValue) && !spaceLen) {
						lastValue += '.';
					} else if(isNum(lastValue)) {
						throw new Error(`51, ., ${pos}`);
					} else {
						throw new Error(`52, ., ${pos}`);
					}
				}

				// 如果是字母的话，只能是方法名或者常量名的一部分
				else if(isMethodName(curChar)) {
					if(/^[a-z\d]+$/i.test(lastValue)) {
						if(spaceLen) throw new Error(`53, ${curChar}, ${pos - spaceLen}`);	
						if(/^\d$/.test(lastValue)) throw new Error(`33, ${lastValue}, ${pos - 1}`);
						lastValue += curChar;
					} else if(isOperate(lastValue) || lastValue === '') {
						if(isFirstOp && /[+\-]/.test(lastValue)) {
							isFirstOp = false;
							lastValue += curChar;
						}
						else lastValue = curChar;
					} else {
						throw new Error(`61, ${curChar}, ${pos}`);
					}
					spaceLen = 0;
				}

				// 如果是右圆括号的话, 只能跟在'(', ',' '' 变量名的后面
				else if(curChar === '(') {
					if(/^\(|,$/.test(lastValue) || lastValue === '') {
						opStack.unshift(curChar);	
					} else if(isOperate(lastValue)) {
						if(isFirstOp && /^[+\-]$/.test(lastValue)) {
							isFirstOp = false;
							opStack.unshift(lastValue + curChar);
						} else {
							opStack.unshift(curChar);
						}
					} else if(isMethodName(lastValue)) {
						if(isMethod(lastValue)) {
							opStack.unshift(lastValue + curChar);
						} else {
							throw new Error(`32, ${lastValue}, ${pos - spaceLen - lastValue.length}`)
						}
					} else {
						throw new Error(`14, ${curChar}, ${pos}`);
					}
					lastValue = curChar;
					spaceLen = 0;
				}

				else if(curChar === ',') {
					if(!opStack.some(v => /\(/.test(v))) throw new Error(`15, ${curChar}, ${pos}`);
					if(isMethodName(lastValue) || isNum(lastValue) || /^(π|\))$/.test(lastValue)) {
						if(isMethodName(lastValue) || lastValue === 'π') {
							if(!isConstant(lastValue)) {
								throw new Error(`31, ${lastValue}, ${pos - spaceLen - lastValue.length}`);
							} else {
								valueStack.unshift(constants[lastValue]);
							}
						} else if(isNum(lastValue)) {
							valueStack.unshift(lastValue);
						}
						while( opStack.length && !(/[(,]/.test(opStack[0]))) {
							let num2 = valueStack.shift(), 
								num1 = valueStack.shift();
							valueStack.unshift(op[opStack.shift()](num1, num2));
						}
					} else {
						throw new Error(`15, ${curChar}, ${pos}`)
					}
					opStack.unshift(curChar);
					lastValue = curChar;
					spaceLen = 0;
				}

				else if(curChar === ')') {
					if(isNum(lastValue) || isMethodName(lastValue) || /(π|\))$/.test(lastValue)) {
						if(isNum(lastValue)) {
							valueStack.unshift(lastValue);						
						} else if(lastValue !== ')') {
							if(!isConstant(lastValue)) throw new Error(`31, ${lastValue}, ${pos - spaceLen - lastValue.length}`);
							valueStack.unshift(constants[lastValue]);	
						}

						let arg = [];
						if(!opStack.some(v => /\(/.test(v))) {
							throw new Error(`16, ${curChar}, ${pos}`);
						}

						while(1) {
							if(/^[+\-*/%^]$/.test(opStack[0])) {
								valueStack.unshift(op[opStack.shift()].apply(null, [valueStack.shift(), valueStack.shift()].reverse()));
							} else if(/^,$/.test(opStack[0])) {
								opStack.shift();
								arg.unshift(+valueStack.shift());
							} else if(/\($/.test(opStack[0])) {
								let isPositive = /[+\-]/.test(opStack[0][0]) ? opStack[0][0] === '+' : true;
								if(/[+\-]/.test(opStack[0][0])) opStack[0] = opStack[0].slice(1);
								arg.unshift(+valueStack.shift());
								if(opStack[0].length !== 1) {
									try { 
										valueStack.unshift(util[opStack[0].slice(0, -1)].apply(null, arg) * (isPositive? 1:-1));
									} catch(e) {
										throw new Error(`${e.message}, ${pos}`);
									}
								} else {
									valueStack.unshift(arg.pop() * (isPositive? 1:-1));
								}
								opStack.shift();
								break;
							} else {
								throw(`unknow Error`);
							}
						}

						// 去掉左括号后，计算之前的运算
						while( opStack.length && !(/\(|,/.test(opStack[0]))) {
							let num2 = valueStack.shift(), 
								num1 = valueStack.shift();
							valueStack.unshift(op[opStack.shift()](num1, num2));
						}

					} else if(lastValue === '(') {
						if(opStack[0].length !== 1) {
							try {
								valueStack.unshift(util[opStack[0].slice(0, -1)]());
							} catch(e) {
								throw new Error(`${e.message}, ${pos}`);
							}
						}
						opStack.shift();
					} else {
						throw new Error(`16, ${curChar}, ${pos}`);
					}
					lastValue = curChar;
					spaceLen = 0;
				}

				// 如果是运算符
				else if(isOperate(curChar)) {
					// 当表达式第一位是运算符的时候就应该报错, 如表达式*3+2或3+(%3)
					// 当运算符前面的lastValue不是数值,变量名或者右圆括号)的时候应该报错
					// 但是有例外， 比如-2+3, 又或者3+(-2),这应该是合法的表达式
					// 这时候，应该改变外部变量isFirstOp为true, 并且不报错。
					// 然后等遍历到后续的数字，将带有前置符的数字入栈
					if(/^\(?,?$/.test(lastValue) || lastValue === '') {
						if(/[+\-]/.test(curChar)) {
							isFirstOp = true;
							lastValue = curChar;
							spaceLen = 0;
							continue;
						} else {
							throw new Error(`12, ${curChar}, ${start + pos}`);
						}
					}

					// 结算前面的lastValue
					// lastValue的可能性是(PS: \s类字符已遍历时忽略) 
					// 1. 数字, 入valueStack栈
					// 2. 常量, 计算其值后入valueStack栈, 如果不存在这个常量就报错
					// 3. 右括号 ) , 这种情况什么都不做，在遍历到右括号时候处理
					// 如果不是上面俩种可能，则代表此运算符前还是运算符,报错
					else if(isNum(lastValue)) {
						valueStack.unshift(lastValue);
					} else if(isMethodName(lastValue) || lastValue === 'π') {
						if(isConstant(lastValue)) {
							valueStack.unshift(constants[lastValue]);
						} else {
							throw new Error(`31, ${lastValue}, ${pos - lastValue.length - spaceLen}`)
						}
					} else if(lastValue !== ')') {
						throw new Error(`41, ${curChar}, ${pos}`);
					}
					// 判断栈中内容
					// 如果运算符优先级不大于栈顶，则出运算符栈栈顶的运算符
					// 再出 运算值栈栈顶的俩个元素， 进行运算
					// 将运算结果推入 运算值栈栈顶
					// 然后继续判断优先级， 
					// 直到满足一下条件
				    // 1. 运算符栈有元素
					// 2. 目前的优先级不高于栈顶
					// 3. 栈顶不是逗号或者圆括号：, (
					// 运算符的可能性： + - * / % ^ ( ) ,
					while( opStack.length 
						   && !(/\(|,/.test(opStack[0])) 
						   && !compareLevel(curChar, opStack[0]) ) {
						let num2 = valueStack.shift(), 
							num1 = valueStack.shift();
						valueStack.unshift(op[opStack.shift()](num1, num2));
					}
					// 将目前的运算符推入栈顶
					opStack.unshift(curChar);
					lastValue = curChar;
					spaceLen = 0;
				}

				// 如果以上都不是，那只能直接报错了。
				// 错误代码11, 表示无法识别的字符
				else {
					throw new Error(`11, ${curChar}, ${pos}`);
				}


			}

			if(isOperate(lastValue)) {
				throw new Error(`17, ${lastValue}, ${len - 1 - spaceLen}`)
			} else if(isNum(lastValue)) {
				valueStack.unshift(lastValue);
			} else if(isMethodName(lastValue) || lastValue === 'π') {
				if(!isConstant(lastValue))throw new Error(`17, ${lastValue}, ${pos - 1 - spaceLen}`);
				else valueStack.unshift(constants[lastValue]);
			}

			while(opStack.length && !(/\(,/.test(opStack[0]))) {
				let num2 = valueStack.shift(), 
					num1 = valueStack.shift();
				valueStack.unshift(op[opStack.shift()](num1, num2));
			}

			if(!opStack.length && valueStack.length === 1) return valueStack[0];
			else throw new Error(`71`);
		}

		try {
			res = innerCaculate(str);
		} catch(e) {
			console.log(e.message);
			res = e.message.split(/\s*,\s*/);
		}
		// 如果结果是数字则返回数字， 如果结果是错误字符串，则解析成数组
		// 错误字符串解析成数组后，
		// 第一个元素表示错误代码
		// 第二个元素表示错误字符或方法常量名
		// 第三个元素表示错误所在的位置索引
		return typeof res === 'object' ? res : +(+res).toFixed(15);
	}

	// 如果合法，返回true， 反之返回包含错误信息的字符串
	const validVarible = (name, value) => {
		if(/^[a-z][a-z\d]*$/i.test(name) && isNum(value)) {
			return constants[name] ? [81] : true;
		} else {
			return /^[a-z_]\w*$/i.test(name) ? [83] : [82];
		}
	};

	const createVarible = (name, value) => constants[name] = +value;

	const validMethod = (name, body) => {
		if(!(/^[a-z][a-z\d]*$/i.test(name))) {
			return [85];
		} else {
			if(util[name]) return [84];
			else {
				// 让方法体跑一遍，就知道其是不是合法的了
				// 这个replace可能与createMethod中的replace重复了
				// 某种意义上可以封装一下后复用
				let res = caculate(body.replace(/\s/g, '')
										.replace(/\b[a-z][a-z\d]*(?!\(|\w)/ig, v => util[v] ? util[v] : 1));
				return typeof res === 'number' ? true : [86];
			}
		}
	};


	const createMethod = (name, body) => {

		// 外部自定义方法调用
		var arr = [],
			isArgStrict = status.isArgStrict;
		body = body.replace(/\s/g, '')
					.replace(/\b[a-z][a-z\d]*(?!\(|\w)/g, v => {
						if(util[v]) return util[v];
						else {
							if(arr.indexOf(v) === -1) arr.push(v); 
							return v;
						}
					});

		function fn(...arg) {
			var res;
			if(arg.length < arr.length) {
				throw new Error(`21, ${name}`);
			} else if(arg.length > arr.length) {
				if(isArgStrict) throw new Error(`22, ${name}`);
			}
			res = caculate(body.replace(RegExp(`\\b(${arr.join('|')})\\b`, 'g'), v => arg[arr.indexOf(v)] || v));
			if(typeof res !== 'number') throw new Error(`unknow error at custom method`);
			return res;
		}
		util[name] = fn;
	};


	// 将 改变模式 和 创建新方法或常量 的接口挂载在caculate函数上
	caculate.create = {
		validMethod: validMethod,
		createMethod: createMethod,
		validVarible: validVarible,
		createVarible: createVarible
	}

	caculate.changeModel = {
		changeArgModel: () => status.isArgStrict = +!status.isArgStrict,
		changeIsAngle: () => status.isAngle = !status.isAngle
	}

	module.exports = caculate;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var status = __webpack_require__(3)

	// math method
	var util = {
		
		'abs': Math.abs,

		'avg': (...arr) => util.sum.apply(null, arr) / arr.length,

		'sin': Math.sin,

		'cos': Math.cos,

		'tan': Math.tan,

		'cot': num => Math.cos(num) / Math.sin(num),

		'acos': Math.acos,

		'acosh': Math.acosh || function(num) {return Math.log(num + Math.sqrt(num * num - 1))},

		'asin': Math.asin,

		'atan': Math.atan,

		'asinh': Math.asinh || function(num) {return num === -Infinity ? num : Math.log(num + Math.sqrt(num * num + 1))},

		'atanh': Math.atanh || function(num) {return Math.log((1 + num)/(1 - num)) / 2},

		'atan2': Math.atan2,

		'logMutil' : (num1, num2) => Math.log(num1) / Math.log(num2),

		'cbrt': Math.cbrt || function(num) {return Math.pow(num, 1/3)},

		'sum': (...arg) => arg.reduce((s, v)=> s + v, 0),

		'pow': Math.pow,

		'fac': n => new Array(n+1).join('1').split('').reduce((s, v, i) => s*(i+1), 1),

		'HCF': function hcf(a, b) {
			return a%b ? hcf(b, a%b) : b;
		},


		'log': Math.log10 || function(num) {util.log(num, 10)},

		'ln': Math.log,

		// change between angle and radian
		angle2rad: n => n * 2 * Math.PI / 360,
		rad2angle: n => n * 180 / Math.PI
	};


	// a map for check number of arguments.
	let argNumbers = {
		'abs': 1,
		'avg': 2, 
		'sin': 1,
		'cos': 1,
		'tan': 1,
		'cot': 1,
		'acos': 1,
		'acosh': 1,
		'asin': 1,
		'atan': 1,
		'asinh': 1,
		'atanh': 1,
		'atan2': 1,
		'log': 1,
		'ln': 1,
		'logMutil' : 2,
		'cbrt': 1,
		'sum': 2,
		'pow': 2,
		'fac': 1,
		'HCF': 2
	};

	// a trigonometry function map for next wrap function 
	let trigonometry = [	'sin',
							'cos',
							'tan',
							'cot',
							'acos',
							'acosh', 
							'asin',
							'atan',
							'asinh', 
							'atanh', 
							'atan2'    ];

	// wrap util method 
	// 1. check arguments number
	// 2. if the method is trigonometry function, judge the status.isAngle
	for(let key in argNumbers) {
		let oriFn = util[key],
			argNum = argNumbers[key],
			isTrigonometry;
		util[key] = function(...arg) {
			let len = arg.length,
				isAngle = status.isAngle,
				isArgStrict = status.isArgStrict;
			// throw new Error if arguments number not match
			// error string will present like 'errCode, methodName'
			if(len < argNum) {
				// if the actual arguments less than require arguments number
				throw new Error(`21, ${key}`);
			} else if(len > argNum) {
				if(isArgStrict) {
					throw new Error(`22, ${key}`);
				}
			}
			isTrigonometry = trigonometry.indexOf(key) > -1;
			return oriFn.apply(null, isTrigonometry && isAngle ? arg.map(v => util.angle2rad(v)) : arg); 
		}
		

		// mount the arguments number on function
		util[key].argNum = argNum;

	}


	module.exports = util;

/***/ },
/* 3 */
/***/ function(module, exports) {

	let status = {
		isAngle: true,
		isArgStrict: false
	};

	module.exports = status;


/***/ },
/* 4 */
/***/ function(module, exports) {

	var constants =  {
		'e': Math.E,
		'π': Math.PI
	};

	module.exports = constants;

/***/ },
/* 5 */
/***/ function(module, exports) {

	var message = {
		'11': '不合法的字符',
		'13': '出现在最后的运算符',
		'14': '不合法的左括号',
		'15': '不合法的逗号', 
		'16': '不合法的右括号',
		'17': '不合法的运算符',
		'18': 'π的使用错误',
		'19': '数字使用错误',
		'21': '传入方法中的参数过少',
		'22': '传入方法中的参数过多',
		'31': '常量名不存在', 
		'32': '方法名不存在', 
		'33': '变量名不能以数字开头',
		'41': '重复的运算符号',
		'51': '重复的小数点, 数字中小数点只能出现一次',
		'52': '非法的小数点, 小数点只能出现在数字中间',
		'53': '数字间不合法的空格',
		'55': 'π后不能接字母或者数字',
		'61': '字母使用错误',
		'71': '多余的逗号或者左括号',
		'81': '已经有同名常量存在',
		'82': '不合法的常量名, 常量名只能由字母和数字组成，且只能由字母开头',
		'83': '不合法的常量数值',
		'84': '已经有同名方法存在',
		'85': '不合法的方法名',
		'86': '不合法的方法体'
	}

	module.exports = message;

/***/ }
/******/ ]);
//# sourceMappingURL=main.min.js.map